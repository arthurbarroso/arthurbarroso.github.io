<html lang="en" xml.lang="en" xmlns="http://www.w3.org/1999/xhtml"><head><meta charset="utf-8" /><meta content="Testing reagent dom components and screens using shadow-cljs and Clojurescript" name="description" /><meta content="KLXtbzGXgE_BcqGEwJv7vCVH6-XMLskVDgd-rRVoZHg" name="google-site-verification" /><meta content="https://www.arthurbrrs.me/img/collage/publicint.png" property="og:image" /><meta content="clojure" name="keywords" /><meta content="width=device-width, initial-scale=1" name="viewport" /><meta content="shadow-cljs reagent tests dom react clojurescript" name="keywords" /><meta content="Testing reagent dom components and screens using shadow-cljs and Clojurescript" name="description" /><meta content="Testing reagent dom components and screens using shadow-cljs and Clojurescript" property="og:description" /><meta content="https://arthurbrrs.me/dom-tests-pt-br.html" property="og:url" /><meta content="Testando a DOM usando shadow-cljs e Reagent" property="og:title" /><meta content="article" property="og:type" /><meta content="https://www.arthurbrrs.me/img/collage/publicint.png" property="og:image" /><link href="https://arthurbrrs.me/dom-tests-pt-br" rel="canonical" /><link href="css/favicon.ico" rel="shortcut icon" /><link href="https://fonts.googleapis.com" rel="preconnect" /><link crossorigin="crossorigin" href="https://fonts.gstatic.com" rel="preconnect" /><link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,300;0,400;0,500;0,700;0,900;1,700&amp;display=swap" rel="stylesheet" /><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/github.min.css" rel="stylesheet" /><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.min.js"></script><link href="/css/screen.css" rel="stylesheet" /><title>((arthur barroso)): Testando a DOM usando shadow-cljs e Reagent</title></head><body><nav class="navbar"><div class="container"><div class="navbar-header"><a class="navbar-title" href="/">((arthur barroso))</a><ul class="navbar-list"><li><a class="navbar-link" href="/archives">archives</a><a class="navbar-link" href="/collage">collage</a><a class="navbar-link" href="/about">about</a></li></ul></div></div></nav><div class="container"><div class="row"><div><div id="content"><div id="post"><div class="post-header"><div class="row" id="post-meta"><div class="col-lg-6">2021-09-13</div></div><h2>Testando a DOM usando shadow-cljs e Reagent</h2><div><p>Há algum tempo tenho tentado desenvolver <a href='https://github.com/arthurbarroso/brundij'>brundij</a>, uma ferramenta open-source para fazer squad health checks. Eu decidi usar Clojure e Clojurescript para construí-la (já estava estudando Clojure por alguns meses, mas ainda me sentia um completo iniciante, então decidi que construir uma ferramenta usando Clojure poderia me ajudar a entender algumas coisas). Também decidi usar <code>shadow-cljs</code> para o setup do projeto.</p><p>Tudo corria bem até o momento em que precisei rodar testes relacionados à DOM: aparentemente poucos dos desenvolvedores usando Clojurescript faziam testes no estilo react-testing-library. O único post que achei falando sobre testes de DOM/componentes/telas era de dois anos atrás. TUdo isso me levou a criar esse post, em que tentarei ajudar iniciantes em Clojurescript a fazer esse tipo de testes em suas aplicações <code>shadow-cljs</code> e <code>reagent</code>.</p><h3>Primeira tentativa:</h3><p>Iniciaremos com um projeto básico utilizando shadow-cljs e reagent. Para criar o projeto, podemos usar o leiningen rodando o comando <code>lein new re-frame app</code>. Com o app inicializado, iremos criar nosso primeiro componente -um botão simples:<pre><code class="clj">;;src/app/components/button.cljs
&#40;ns app.components.button&#41;

&#40;defn button &#91;{:keys &#91;on-click text disabled&#93;}&#93;
  &#91;:button
   {:type &quot;button&quot;
    :disabled disabled
    :on-click #&#40;on-click&#41;}
   text&#93;&#41;
</code></pre></p><p>Esse é um componente <em>bem</em> básico: ele recebe um handler/função <code>on-click</code>, um texto a ser exibido (<code>text</code>) e um booleano <code>disabled</code>. Com o botão criado, vamos tentar renderizá-lo em nossos testes. Para isso, precisamos primeiro criar uma configuração de build de testes em nosso <code>shadow-cljs.edn</code> e depois sim escrever um teste:<pre><code class="clj">  :test {:target :browser-test
         :test-dir &quot;resources/public/js/test&quot;
         :devtools  {:http-port          8021
                     :http-root          &quot;resources/public/js/test&quot;}}}}
</code></pre></p><pre><code class="clj">;;test/app/button&#95;test.cljs
&#40;ns app.button-test
  &#40;:require &#91;app.components.button :refer &#91;button&#93;&#93;
            &#91;cljs.test :refer-macros &#91;deftest is testing&#93;&#93;
            &#91;reagent.dom :as rdom&#93;&#41;&#41;
            
&#40;deftest button-component-test
  &#40;testing &quot;Renders correctly&quot;
    &#40;rdom/render &#91;button {:on-click #&#40;println &quot;hi&quot;&#41;
                          :text &quot;button&quot;
                          :disabled false}&#93;
                 &#40;.getElementById js/document &quot;app&quot;&#41;&#41;
    &#40;is &#40;= true true&#41;&#41;&#41;&#41;
</code></pre><p>Se rodarmos <code>npx shadow-cljs watch test</code>, teremos nosso ambiente de testes rodando. Se você configurou a build de testes do mesmo jeito que eu, você poderá navegar até <code>localhost:8021</code> e checar que nosso teste está falhando com uma "uncaught exception": <code>target container is not a DOM element</code></p><p>Esse erro é causado pela ausência de um element <code>div</code> com o id <code>app</code> dentro de nosso arquivo HTML de teste (que é utilizado pelo shadow para montar o ambiente de testes). Poderíamos modificar esse arquivo manualmente adicionando essa div lá, mas abordaremos esse problema de uma outra forma.</p><h3>Renderizando</h3><p>Como visto acima, precisamos ter uma <code>div</code> com o id <code>app</code> em nossa DOM antes de rodar os testes. UMa maneira de fazer isso sem editar diretamente o arquivo HTML dos testes é usando a função <code>use-fixtures</code> (disponível em clojure.test e cljs.test). Podemos então definir algumas funções que devem ser executadas antes de nossos testes. Vamos criar uma fixture que inserirá a div que precisamos em nossa DOM antes de rodar nossos test cases:</p><pre><code class="clj">;;test/app/button&#95;test.cljs
&#40;ns app.button-test
  &#40;:require &#91;app.components.button :refer &#91;button&#93;&#93;
            &#91;cljs.test :refer-macros &#91;deftest is testing use-fixtures&#93;&#93;
            &#91;reagent.dom :as rdom&#93;&#41;&#41;

&#40;defn create-app-element &#91;f&#93;
  &#40;.appendChild &#40;.-body js/document&#41; ;; gets the Body element
                &#40;doto &#40;.createElement js/document &quot;div&quot;&#41; ;; creates a new div
                  &#40;-&gt; &#40;.setAttribute &quot;id&quot; &quot;app&quot;&#41;&#41; ;; sets the new div id to be `app`
                  &#40;-&gt; &#40;.setAttribute &quot;style&quot; &quot;display:none;&quot;&#41;&#41;&#41;&#41; ;; makes that div invisible
  &#40;f&#41;&#41;

&#40;use-fixtures :once create-app-element&#41;

&#40;deftest button-component-test
  &#40;testing &quot;Renders correctly&quot;
    &#40;rdom/render &#91;button {:on-click #&#40;println &quot;hi&quot;&#41;
                          :text &quot;button&quot;
                          :disabled false}&#93;
                 &#40;.getElementById js/document &quot;app&quot;&#41;&#41;
    &#40;is &#40;= true true&#41;&#41;&#41;&#41;
</code></pre><p>A função <code>create-app-element</code> nos será muito util e a utilizaremos em cada um de nossos arquivos de teste. Ela basicamente cria uma div, seta o id desta div como <code>app</code> e aplica <code>style= display:none</code> para que esse elemento não fique aparecendo na tela de testes do shadow-cljs (a que vimos acessando <code>localhost:8021</code>). Isso deve ser o suficiente para rodarmos o nosso teste sem recebermos erros quando acessarmos o report de testes.</p><h3>Fazendo asserções sobre os componentes</h3><p>Com os componentes renderizando nos testes, podemos agora fazer asserções sobre eles. Suponha que o objetivo seja testar que o botão realmente renderiza: podemos fazer isso de várias maneiras, sendo uma delas checar se a prop <code>text</code> que esse botão recebe acaba sendo renderizada na DOM:<pre><code class="clj">&#40;deftest button-component-test
  &#40;testing &quot;Renders correctly&quot;
    &#40;rdom/render &#91;button {:on-click #&#40;println &quot;hi&quot;&#41;
                          :text &quot;button&quot;
                          :disabled false}&#93;
                 &#40;.getElementById js/document &quot;app&quot;&#41;&#41;
    &#40;let &#91;app-element &#40;.getElementById js/document &quot;app&quot;&#41;
          button &#40;-&gt; &#40;.getElementsByTagName app-element &quot;button&quot;&#41;
                     &#40;first&#41;&#41;&#93;
      &#40;is &#40;= &quot;button&quot; &#40;.-textContent button&#41;&#41;&#41;&#41;&#41;&#41;
</code></pre></p><p>Esse, no entanto, não é um bom teste: ele simplesmente checa se o componente renderiza. Para testarmos os comportamentos de nossos componentes precisamos interagir com eles como um usuário faria, e é aqui que usaremos <code>react-dom/test-utils</code>.</p><p>Com o <code>react-dom/test-utils</code>, podemos simular eventos de um usuário e checar se esses eventos trazem mudanças para nossos componentes. No nosso caso, podemos clicar no botão e checar se o <code>on-click</code> dele é ativado:<pre><code class="clj">&#40;ns app.button-test
  &#40;:require &#91;app.components.button :refer &#91;button&#93;&#93;
            &#91;cljs.test :refer-macros &#91;deftest is testing use-fixtures&#93;&#93;
            &#91;reagent.core :as reagent&#93;
            &#91;reagent.dom :as rdom&#93;
            &#91;&quot;react-dom/test-utils&quot; :as dom-test-utils&#93;&#41;&#41;

&#40;defn create-app-element &#91;f&#93;
  &#40;.appendChild &#40;.-body js/document&#41;
                &#40;doto &#40;.createElement js/document &quot;div&quot;&#41;
                  &#40;-&gt; &#40;.setAttribute &quot;id&quot; &quot;app&quot;&#41;&#41;
                  &#40;-&gt; &#40;.setAttribute &quot;style&quot; &quot;display:none;&quot;&#41;&#41;&#41;&#41;
  &#40;f&#41;&#41;

&#40;use-fixtures :once create-app-element&#41;

&#40;deftest button-component-click-test
  &#40;testing &quot;Uses the supplied `on-click` property&quot;
    &#40;let &#91;ra &#40;reagent/atom 1&#41;&#93; ;; we create a new atom with the value of 1
      &#40;rdom/render &#91;button {:on-click #&#40;swap! ra inc&#41; ;; we define that 
                                                      ;;on-click should increment 
                                                      ;;our atom's value
                            :text &quot;button&quot;
                            :disabled false}&#93;
                   &#40;.getElementById js/document &quot;app&quot;&#41;&#41;
      &#40;let &#91;app-element &#40;.getElementById js/document &quot;app&quot;&#41;
            button &#40;-&gt; &#40;.getElementsByTagName app-element &quot;button&quot;&#41;
                       &#40;first&#41;&#41;&#93; ;; gets the button element
        &#40;.click dom-test-utils/Simulate button&#41; 
        ;; react-dom/test-utils simulates a user click
        &#40;is &#40;= 2 @ra&#41;&#41;&#41;&#41;&#41;&#41; ;; ra's value should've been incremented
</code></pre></p><p>O teste usa um <code>atom</code> do <code>reagent</code>, mas poderia usar re-frame, por exemplo.</p><h3>Limpando a DOM entre testes</h3><p>O setup atual tem um problema: não limpamos a DOM entre os testes. Isso significa que podem ocorrer conflitos entre cada um de nossos <code>deftest</code>. Podemos resolver isso, mas não com o código que temos atualmente: como usamos <code>reagent-dom/render</code> para renderizar nossos componentes na div com id <code>app</code>, não temos esses componentes como "filhos" da div, e sim a div como o componente (o componente toma o lugar da div).</p><p>O primeiro passo para podermos limpar a DOM com esse setup será definir uma função <code>append-container</code>. Essa função receberá um elemento destino e um id como argumentos. Com esses dados em mãos, ela criará uma div com o id que recebeu e fará com que essa div seja "filha" do elemento destino. Definiremos então outra função chamada <code>dom-cleanup!</code>, que será uma fixture e que utilizará a função <code>clojure.browser.dom/remove-children</code>, que remove os elementos "filhos" de um elemento escolhido.</p><pre><code class="clj">&#40;ns app.button-test
  &#40;:require &#91;app.components.button :refer &#91;button&#93;&#93;
            &#91;cljs.test :refer-macros &#91;deftest is testing use-fixtures&#93;&#93;
            &#91;clojure.browser.dom :refer &#91;remove-children&#93;&#93;
            &#91;reagent.core :as reagent&#93;
            &#91;reagent.dom :as rdom&#93;
            &#91;&quot;react-dom/test-utils&quot; :as dom-test-utils&#93;&#41;&#41;

&#40;defn create-app-element &#91;f&#93;
  &#40;.appendChild &#40;.-body js/document&#41;
                &#40;doto &#40;.createElement js/document &quot;div&quot;&#41;
                  &#40;-&gt; &#40;.setAttribute &quot;id&quot; &quot;app&quot;&#41;&#41;
                  &#40;-&gt; &#40;.setAttribute &quot;style&quot; &quot;display:none;&quot;&#41;&#41;&#41;&#41;
  &#40;f&#41;&#41;

&#40;defn dom-cleanup! &#91;f&#93;
  &#40;remove-children &quot;app&quot;&#41;
  &#40;f&#41;&#41;

&#40;defn append-container &#91;target id&#93;
  &#40;let &#91;container &#40;.getElementById js/document id&#41;&#93;
    &#40;if container
      container
      &#40;.appendChild target &#40;doto &#40;.createElement js/document &quot;div&quot;&#41;
                             &#40;-&gt; &#40;.setAttribute &quot;id&quot; id&#41;&#41;&#41;&#41;&#41;&#41;&#41;

&#40;use-fixtures :once create-app-element&#41;
&#40;use-fixtures :each dom-cleanup!&#41;
</code></pre><p>Com essas funções em mãos, apenas precisamos garantir que nossos testes usem a função <code>append-container</code> para renderizar os componentes:<pre><code class="clj">&#40;deftest button-component-click-test
  &#40;testing &quot;Uses the supplied `on-click` property&quot;
    &#40;let &#91;ra &#40;reagent/atom 1&#41;&#93;
      &#40;rdom/render &#91;button {:on-click #&#40;swap! ra inc&#41;
                            :text &quot;button&quot;
                            :disabled false}&#93;
                   &#40;append-container &#40;.getElementById js/document &quot;app&quot;&#41;
                                     &quot;button-click-test&quot;&#41;&#41; 
                                     ;; this creates a children div
                                     ;; with the id `button-click-test`
      &#40;let &#91;app-element &#40;.getElementById js/document &quot;button-click-test&quot;&#41; 
      ;; queries for the div we've just created
            button &#40;-&gt; &#40;.getElementsByTagName app-element &quot;button&quot;&#41;
                       &#40;first&#41;&#41;&#93;
        &#40;.click dom-test-utils/Simulate button&#41;
        &#40;is &#40;= 2 @ra&#41;&#41;&#41;&#41;&#41;&#41;
</code></pre></p><h3>Usando o Karma</h3><p>Para rodar os testes acima numa CI, será necessário usar o <a href='https://karma-runner.github.io/latest/index.html'>karma</a>. Karma é um test runner para javascript e é recomendado pelo user guide do <code>shadow-cljs</code>. Para usá-lo, vamos adicionar as dependências do karma às nossas dependências de desenvolvimento no nosso <code>package.json</code>, faremos algumas alterações em nosso <code>shadow-cljs.edn</code> e criaremos um arquivo  <code>karma.conf.js</code>.</p><pre><code class="json">//package.json

{
 &quot;devDependencies&quot;: {
  &quot;karma&quot;: &quot;&#94;2.0.0&quot;,
  &quot;karma-chrome-launcher&quot;: &quot;&#94;2.2.0&quot;,
  &quot;karma-cljs-test&quot;: &quot;&#94;0.1.0&quot;,
  &quot;shadow-cljs&quot;: &quot;2.15.2&quot;
 }
}
</code></pre><pre><code class="clj"> ;;shadow-cljs.edn
  :ci {:target :karma
       :output-to &quot;target/ci.js&quot;}}}
</code></pre><pre><code class="clj">//karma.conf.js
module.exports = function &#40;config&#41; {
    config.set&#40;{
        browsers: &#91;'ChromeHeadless'&#93;,
        // The directory where the output file lives
        basePath: 'target',
        // The file itself
        files: &#91;'ci.js'&#93;,
        frameworks: &#91;'cljs-test'&#93;,
        plugins: &#91;'karma-cljs-test', 'karma-chrome-launcher'&#93;,
        colors: true,
        logLevel: config.LOG&#95;INFO,
        client: {
            args: &#91;&quot;shadow.test.karma.init&quot;&#93;,
            singleRun: true
        }
    }&#41;
};
</code></pre><p>Com tudo isso feito, poderemos rodar nossos testes em um ambiente de CI rodando o comando <code>npx shadow-cljs compile ci &amp;&amp; npm run karma start --single-run</code></p><h1>React testing library</h1><p>Não falarei muito sobre o <code>react-testing-library</code> nesse post. Um excelente post explicando como utilizar o rtl para testar aplicativos Clojurescript já existe. Eu cheguei a tentar seguir o post/tutorial (forçando a versão do RTL para 6.1.2) e consegui fazer meus testes rodarem. Acredito que a maior vantagem do RTL é evitar todo esse processo de interop e manipular a DOM, mas isso não me parece o suficiente para usá-lo no momento.</p></div></div></div></div></div></div><footer>Copyright &copy; 2021 Arthur Barroso</footer></div></body><script src="/js/clojure_highlighter.js"></script><script>document.addEventListener('DOMContentLoaded', (event) => {
      document.querySelectorAll('pre code:not(.clj)').forEach((el) => {
          hljs.highlightElement(el);
      });
     });</script></html>