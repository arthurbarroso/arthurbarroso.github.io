<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
    <meta charset="utf-8"/>
    <title>((arthur barroso)): Experimentos tentando fazer pre-rendering de React em Clojure(script)</title>
    
<meta name="keywords" content="">

<meta name="description" content="A blog post about different React pre-rendering techniques and approaches in Clojure(script)">

<meta property="og:description" content="A blog post about different React pre-rendering techniques and approaches in Clojure(script)">

<meta property="og:url" content="" />
<meta property="og:title" content="Experimentos tentando fazer pre-rendering de React em Clojure(script)" />
<meta property="og:type" content="article" />
<meta property="og:image" content="https://www.arthurbrrs.me/img/collage/publicint.png"/>

    <link rel="canonical" href="">
    <link rel="shortcut icon" href="css/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,300;0,400;0,500;0,700;0,900;1,700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/github.min.css"/>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.min.js"></script>
    <link href="css/screen.css" rel="stylesheet" type="text/css" />
</head>
<body>


<nav class="navbar">
    <div class="container">
        <div class="navbar-header">
            <a class="navbar-title" href="/">((arthur barroso))</a>
            <ul class="navbar-list">
              <li><a href="/archives">archives</a></li>
              <li><a href="/collage">collage</a></li>
              <li><a href="/about">about</a></li>
            </ul>
        </div>
    </div>
</nav>


<div class="container">
    <div class="row">
        <div>
            <div id="content">
                
<div id="post">
    <div class="post-header">
        <div id="post-meta" class="row">
            <div class="col-lg-6">2021-09-21</div>
            
            <span class="col-lg-6">By: Arthur Barroso</span>
            
            
        </div>
        <h2>Experimentos tentando fazer pre-rendering de React em Clojure(script)</h2>
    </div>
    <div>
        
        <p>Por cerca de três meses eu estive meio fascinado com a ideia de fazer pre-render das minhas aplicações react. Tudo isso começou quando comecei a desenvolver minha aplicação <a href='https://github.com/arthurbarroso/brundij'>brundij</a> e percebi que não conseguiria obter boas performances sem usar técnicas de pre-rendering, o que, por fim, me levou a ler bastante coisa sobre o assunto.</p><p>Eu desenvolvo aplicações React por algum tempo, mas nunca precisei construir qualquer mecânismo de pre-rendering sem frameworks como Gatsby ou Next, então fazer o pre-render "na mão" foi um desafio para mim. Acabei decidindo escrever esse post falando sobre todas as coisas que tentei e o que penso sobre cada uma dessas. Esse post <strong>não</strong> deve ser visto como um tutorial: tudo aqui é altamente experimental.</p><p>Enquanto escrevia, percebi que este post ficaria <em>bem</em> longo, então também criei um repositório com o código necessário para seguir o tutorial. Você pode checá-lo <a href='https://github.com/arthurbarroso/blog-prerendering-demo'>aqui</a>.</p><h3>Pré-render de aplicações React</h3><p>Pre-rendering em aplicações React é comumente alcançado utilizando frameworks como Gatsby e Next.js. Essas ferramentas/frameworks compartilham uma feature: elas tornam possível gerar o HTML estático das páginas da aplicação enquanto se faz o build. (Next.js também torna possível gerar esse conteúdo a cada request, usando server-side rendering).</p><p>O que acontece para ambas as estratégias (static site generation e server-side rendering) é que as telas/componentes React são renderizadas para uma string que depois se conecta a seus event handlers. Isso significa que o client baixa um HTML estático pré-renderizado e, com o HTML montado, o javascript da página (React) conecta os devidos event handlers. Isso é feito usando <code>ReactDomServer.renderToString&#40;&#41;</code> e <code>React.hydrate&#40;&#41;</code>.</p><h3>Pré-render em Clojurescript</h3><p>Eu gosto de escrever minhas aplicações usando Clojurescript e ainda sim gostaria de poder fazer o pré-render delas. O problema disso é que os frameworks supracitados não funcionam bem com Clojuresccript, como apontado pelo Thomas Heller <a href='https://clojureverse.org/t/creating-websites-with-shadow-cljs-gatsby-or-next-js/2912'>nesse post</a>.</p><p>Isso me levou a pensar em como eu poderia fazer o pré-rendering das minhas aplicações Reagent/re-frame sem precisar subir um servidor Node. Comecei então a procurar por conteúdos sobre o assunto, que me levaram a alguns achados:</p><ul><li><a href='https://nextjournal.com/kommen/react-server-side-rendering-with-graalvm-for-clojure'>React Server Side Rendering with GraalVM for Clojure</a></li><li><a href='https://medium.com/@joelsanchezclj/prerendering-a-re-frame-app-with-chrome-headless-bb875de31fd0'>Prerendering a re-frame app with Chrome headless</a></li><li><a href='https://github.com/pupeno/prerenderer'>pupeno/Prerenderer</a> - que ainda não testei e, portanto, não falarei sobre</li><li><a href='https://github.com/borkdude/nbb'>borkdude/nbb</a></li></ul><p>Esses links me ajudarem a entender algumas coisas e tentar alguns setups diferentes, que descreverei aqui.</p><h3>Primeiro setup: usando GraalVM e Polyglot</h3><p>Esse setup é altamente baseado no post linkado acima, <a href='https://nextjournal.com/kommen/react-server-side-rendering-with-graalvm-for-clojure'>React Server Side Rendering with GraalVM for Clojure</a>, mas decidi mudar alguns detalhes para que isso se adaptasse melhor ao meu workflow:</p><ul><li>Ao invés de usar a versão customizada de Clojurescript usada pelo Nextjournal, optei por usar <code>shadow-cljs</code> e sua versão de Clojurescript.</li><li>Eu gostaria de usar re-frame para controlar o estado da aplicação.Para conseguir isso, precisei procurar um pouco e realizar alguns setups meio "hackish" que não são tão recomendados. Os passos para fazer isso são:</li></ul><p>Criar nosso arquivo <code>deps.edn</code><pre><code class="clj">;;deps.edn
{:deps {org.clojure/clojure {:mvn/version &quot;1.10.3&quot;}
        reagent/reagent {:mvn/version &quot;1.1.0&quot;}
        thheller/shadow-cljs {:mvn/version &quot;2.15.10&quot;}
        re-frame/re-frame {:mvn/version &quot;1.2.0&quot;}
        org.clojure/core.async {:mvn/version &quot;1.3.618&quot;}}

 :paths &#91;&quot;src&quot; &quot;dev&quot;&#93;

 :aliases {:cljs {:main-opts &#91;&quot;-m&quot; &quot;shadow.cljs.devtools.cli&quot;&#93;
                  :paths &#91;&quot;src&quot; &quot;dev&quot;&#93;}

           :repl {:extra-deps {nrepl/nrepl {:mvn/version &quot;0.8.3&quot;}
                               cider/cider-nrepl {:mvn/version &quot;0.26.0&quot;}}
                  :extra-paths &#91;&quot;public/assets&quot;&#93;
                  :main-opts &#91;&quot;-m&quot; &quot;nrepl.cmdline&quot;
                              &quot;--interactive&quot;
                              &quot;--middleware&quot;
                              &quot;&#91;cider.nrepl/cider-middleware&#93;&quot;&#93;}}}
</code></pre></p><p>Configurar o <code>shadow-cljs</code><pre><code class="clj">;;shadow-cljs.edn
{:nrepl {:port 8777}

 :deps true

 :dev-http
 {8280 &quot;public&quot;}

 :builds
   {:app {:target :graaljs
          :output-to &quot;public/assets/graal.js&quot;
          :entries &#91;app.component&#93;
          :jvm-opts &#91;&quot;-Xmx4G&quot;&#93;
          :modules
          {:app {:init-fn &#91;app.component/countinghtml&#93;}}}}}
</code></pre></p><p>Se compilarmos o código usando a configuração acima e tentarmos usar qualquer função assíncrona do javascript como <code>setTimeout</code> ou <code>setInterval</code> receberemos uma mensagem de erro dizendo que async ainda não é suportado pelo target <code>graaljs</code>. Como visto <a href='https://github.com/thheller/shadow-cljs/issues/685'>nessa issue</a> do repositório do <code>shadow-cljs</code>, os "shims" necessários para que Clojurescript rodasse as funções <code>async</code> no target <code>graaljs</code> foram removidos. Para resolver isso, precisaremos fazer com que o <code>shadow-cljs</code> faça um prepend de nosso código com os shims e delete as definições de função não suportada. Isso pode ser feito adicionando a key <code>prepend-js</code> apontando para <a href='https://github.com/clojure/clojurescript/blob/e4300da64c4781735146cafc0ca029046b83944c/src/main/cljs/cljs/bootstrap_graaljs.js'>esse arquivo</a> em nosso módulo app e criando um build hook<pre><code class="clj">;;shadow-cljs.edn
{...
 :builds
   {:app {...
          :modules
            {:app {:init-fn &#91;app.component/countinghtml&#93;}
           :prepend-js &quot;./graal-bootstrap.js&quot;}
          :build-hooks &#91;&#40;util.clean/hook&#41;&#93;}}}
</code></pre></p><p>Hook:<pre><code class="clj">;;src/util/clean.clj
&#40;ns util.clean
  &#40;:require &#91;clojure.java.io :as io&#93;
            &#91;clojure.string :as string&#93;&#41;&#41;

&#40;defn hook
  {:shadow.build/stage :flush}
  &#91;build-state &amp; args&#93;
  &#40;let &#91;original &#40;slurp &#40;io/file &quot;public/assets/graal.js&quot;&#41;&#41;
        start &#40;- &#40;string/index-of original &quot;function graaljs&#95;async&#95;not&#95;supported&#40;&#41;&quot;&#41; 0&#41;
        to-replace &#40;subs original start &#40;+ start 664&#41;&#41;&#93;
    &#40;spit &quot;public/assets/clean.js&quot;
          &#40;-&gt; original
              &#40;string/replace to-replace &quot; &quot;&#41;&#41;&#41;&#41;
  build-state&#41;
</code></pre></p><p>O build hook acima cria uma cópia do código buildado pelo shadow e remove todas as definições <code>async&#95;not&#95;supported</code> do código, fazendo com que nossas chamadas a essas funções rodem as funções dos "shims" ao invés de causar erros. Com isso feito, é hora de configurar o Polyglot e nosso primeiro componente:</p><pre><code class="clj">&#40;ns app.render
  &#40;:require &#91;clojure.java.io :as io&#93;&#41;
  &#40;:import &#40;org.graalvm.polyglot Context Source Engine&#41;
           &#40;org.graalvm.polyglot.proxy ProxyArray ProxyObject&#41;&#41;&#41;

&#40;defn serialize-arg &#91;arg&#93;
  &#40;cond
    &#40;keyword? arg&#41;
      &#40;name arg&#41;

    &#40;symbol? arg&#41;
      &#40;name arg&#41;

    &#40;map? arg&#41;
      &#40;ProxyObject/fromMap &#40;into {} &#40;map &#40;fn &#91;&#91;k v&#93;&#93;
                                           &#91;&#40;serialize-arg k&#41; &#40;serialize-arg v&#41;&#93;&#41;
                                         arg&#41;&#41;&#41;

    &#40;coll? arg&#41;
      &#40;ProxyArray/fromArray &#40;into-array Object &#40;map serialize-arg arg&#41;&#41;&#41;

    :else
      arg&#41;&#41;

&#40;defn execute-fn &#91;context fn &amp; args&#93;
  &#40;let &#91;fn-ref &#40;.eval context &quot;js&quot; fn&#41;
        argsv &#40;into-array Object &#40;map serialize-arg args&#41;&#41;&#93;
    &#40;assert &#40;.canExecute fn-ref&#41; &#40;str &quot;cannot execute &quot; fn&#41;&#41;
    &#40;.execute fn-ref argsv&#41;&#41;&#41;

&#40;defn template-html-2 &#91;react-data&#93;
  &#40;str &quot;&lt;html&gt;
        &lt;head&gt;
       &lt;meta charset=\&quot;utf-8\&quot;&gt;
         &lt;script src=\&quot;/assets/clean.js\&quot;&gt;
         &lt;/script&gt;
        &lt;/head&gt;
        &lt;body&gt;
        &lt;div id=\&quot;root\&quot;&gt;&quot;
       react-data
       &quot;&lt;/div&gt;
       &lt;/body&gt;
       &lt;script&gt;
        app.component.countinghydrate&#40;&#41;;
       &lt;/script&gt;
       &lt;/html&gt;&quot;&#41;&#41;

&#40;defn context-build &#91;&#93;
  &#40;let &#91;engine &#40;Engine/create&#41;&#93;
    &#40;doto &#40;Context/newBuilder &#40;into-array String &#91;&quot;js&quot;&#93;&#41;&#41;
      &#40;.engine engine&#41;
      &#40;.allowExperimentalOptions true&#41;
      &#40;.option &quot;js.experimental-foreign-object-prototype&quot; &quot;true&quot;&#41;
      &#40;.option &quot;js.timer-resolution&quot; &quot;1&quot;&#41;
      &#40;.option &quot;js.java-package-globals&quot; &quot;false&quot;&#41;
      &#40;.out System/out&#41;
      &#40;.err System/err&#41;
      &#40;.allowAllAccess true&#41;
      &#40;.allowNativeAccess true&#41;&#41;&#41;&#41;

&#40;def build-page
  &#40;memoize
    &#40;fn &#91;ctx js-file fun arg&#93;
      &#40;let &#91;context &#40;.build ctx&#41;
            app-s &#40;-&gt; js-file
                      &#40;io/file&#41;
                      &#40;#&#40;.build &#40;Source/newBuilder &quot;js&quot; %&#41;&#41;&#41;&#41;&#93;
        &#40;.eval context app-s&#41;
        &#40;.asString &#40;execute-fn context fun arg&#41;&#41;&#41;&#41;&#41;&#41;
</code></pre><p>ps.: a função serialize-arg foi encontrada <a href='https://github.com/wavejumper/clj-polyglot/blob/e56783822e85d0b75d048c3e6a8b597f0e26724a/src/clj_polyglot/core.clj'>aqui</a></p><p>O componente que utilizaremos para fazer pré-rendering:<pre><code class="clj">&#40;ns app.component
  &#40;:require &#91;app.events :as events&#93;
            &#91;app.subs :as subs&#93;
            &#91;re-frame.core :as re-frame&#93;
            &#91;&quot;react-dom&quot; :as react-dom&#93;
            &#91;reagent.core :as reagent&#93;
            &#91;reagent.dom.server :as dom-server&#93;&#41;&#41;

&#40;defn counting-component &#91;&#93;
  &#40;let &#91;click-2 &#40;reagent/atom 0&#41;
        name &#40;re-frame/subscribe &#91;::subs/name&#93;&#41;
        users &#40;re-frame/subscribe &#91;::subs/users&#93;&#41;&#93;
    &#40;fn &#91;&#93;
      &#91;:div
       &quot;The atom &quot; &#91;:code &quot;click-count&quot;&#93; &quot; has value: &quot;
       @click-2 &quot;. &quot;
       &#91;:p &quot;Name has value &quot; @name&#93;
       &#91;:p &quot;Users:&quot;
        &#40;for &#91;user @users&#93;
          &#94;{:key &#40;:id user&#41;}
          &#91;:p &#40;:first&#95;name user&#41;&#93;&#41;&#93;
       &#91;:p &quot;Test 2&quot;&#93;
       &#91;:input {:type &quot;button&quot; :value &quot;Click me!&quot;
                :on-click #&#40;swap! click-2 inc&#41;}&#93;
       &#91;:button {:on-click #&#40;re-frame/dispatch &#91;::events/change-name &quot;teste&quot;&#93;&#41;}
        &quot;Change name&quot;&#93;
       &#91;:button {:on-click #&#40;re-frame/dispatch &#91;::events/fetch&#93;&#41;}
        &quot;Fetch users&quot;&#93;&#93;&#41;&#41;&#41;

&#40;defn wrapped-counter &#91;&#93;
  &#40;re-frame/dispatch-sync &#91;::events/init-db&#93;&#41;
  &#40;fn &#91;&#93;
    &#91;counting-component&#93;&#41;&#41;

&#40;defn countinghtml &#91;&#93;
  &#40;dom-server/render-to-string &#91;wrapped-counter&#93;&#41;&#41;

&#40;defn &#94;:export countinghydrate &#91;&#93;
  &#40;let &#91;cb &#40;.getElementById js/document &quot;root&quot;&#41;&#93;
    &#40;react-dom/hydrate &#40;reagent/as-element &#91;wrapped-counter&#93;&#41;
                       cb&#41;&#41;&#41;
</code></pre></p><p>Por agora só usaremos event handlers mockados.</p><p>Existem duas maneiras de usar esse setup:</p><ul><li>Com server-side rendering (como visto no post do NextJournal)</li><li>Gerando HTML estático no build e hidratando as páginas no client.</li></ul><h4>Server-side rendering</h4><p>Iremos rodar a função <code>app.render</code> em cada request que nossa aplicação receber. Para montar um servidor base irei usar reitit, ring e jetty.<pre><code class="clj">metosin/reitit {:mvn/version &quot;0.5.5&quot;}
ring/ring {:mvn/version &quot;1.8.1&quot;}
</code></pre></p><p>Criando um handler/router base:<pre><code class="clj">&#40;ns app.server
  &#40;:require &#91;app.render :as renderer&#93;
            &#91;reitit.dev.pretty :as pretty&#93;
            &#91;reitit.ring :as ring&#93;
            &#91;reitit.ring.middleware.exception :as exception&#93;
            &#91;ring.adapter.jetty :as jetty&#93;&#41;&#41;

&#40;def router-options {:exception pretty/exception
                     :middleware &#91;exception/exception-middleware&#93;}&#41;

&#40;defn server &#91;&#93;
  &#40;ring/ring-handler
    &#40;ring/router
      &#91;&quot;&quot;
       &#91;&quot;/assets/&#42;&quot; &#40;ring/create-resource-handler {:root &quot;.&quot;}&#41;&#93;
       &#91;&quot;/&quot; {:get &#40;fn &#91;&#95;&#93;
                    {:body
                       &#40;-&gt; &#40;renderer/build-page
                             &#40;renderer/context-build&#41;
                             &quot;public/assets/clean.js&quot;
                             &quot;app.component.countinghtml&quot;
                             {}&#41;
                           &#40;renderer/template-html-2&#41;&#41;}&#41;}&#93;&#93;&#41;
    router-options&#41;&#41;

&#40;defn run-server &#91;&#93;
  &#40;jetty/run-jetty &#40;server&#41; {:port 4000 :join? false}&#41;&#41;

&#40;comment
  &#40;run-server&#41;&#41;
</code></pre></p><p>Agora rodaremos <code>clj -M:cljs watch app</code> e navegaremos para <code>http://localhost:4000</code> no browser, que mostrará para nós a aplicação pré-renderizada. Pronto, fizemos o server-side rendering usando Graal.</p><h4>Gerando HTMLs estáticos</h4><p>Também é possivel usar o Graal para gerar HTML estáticos de nossa aplicação durante o build. Esses arquivos HTMLs então podem ser hidratados pelo browser. Para fazer isso, podemos simplesmente modificar nosso build-hook para que ele gere HTML usando o graal e salve esses arquivos no nosso diretório <code>public</code><pre><code class="clj">&#40;ns util.clean
  &#40;:require &#91;app.render :as renderer&#93;
            &#91;clojure.java.io :as io&#93;
            &#91;clojure.string :as string&#93;&#41;&#41;

&#40;defn hook
  {:shadow.build/stage :flush}
  &#91;build-state &amp; args&#93;
  &#40;let &#91;original &#40;slurp &#40;io/file &quot;public/assets/graal.js&quot;&#41;&#41;
        start &#40;- &#40;string/index-of original &quot;function graaljs&#95;async&#95;not&#95;supported&#40;&#41;&quot;&#41; 0&#41;
        to-replace &#40;subs original start &#40;+ start 664&#41;&#41;&#93;
    &#40;spit &quot;public/assets/clean.js&quot;
          &#40;-&gt; original
              &#40;string/replace to-replace &quot; &quot;&#41;&#41;&#41;&#41;
  &#40;let &#91;html-to-output &#40;-&gt; &#40;renderer/build-page
                             &#40;renderer/context-build&#41;
                             &quot;public/assets/clean.js&quot;
                             &quot;app.component.countinghtml&quot;
                             {}&#41;
                           &#40;renderer/template-html-2&#41;&#41;&#93;
    &#40;spit &quot;public/prerendered.html&quot; html-to-output&#41;&#41;
  build-state&#41;
</code></pre></p><p>Rodar <code>clj -M:cljs watch app</code> e navegar até <code>http://localhost:8280/prerendered.html</code> deve nos mostrar nossa tela pré-renderizada.</p><h5>Requests HTTP no client</h5><p>Eu optei por não mostrar o código dos event handlers do re-frame de propósito. Você pode ter percebido que existe um evento chamado <code>fetch</code>. Esse evento deveria inciar um request HTTP, que muito provavelmente seria feito usando <code>re-frame-http-fx</code> em uma SPA clojurescript comum.</p><p>O problema é: quando usando o target <code>graaljs</code> será impossível usar <code>cljs-ajax</code>, que é a biblioteca por trás das requests do <code>re-frame-http-fx</code>: no target <code>graaljs</code> não temos acesso à <code>XMLHTTPRequest</code>, que é usado por essas bibliotecas. Para contornar esse problema, criei uma biblioteca que "envelopa" a biblioteca <code>cljs-http</code> em eventos/efeitos do re-frame. Vamos adicioná-la a nossas dependências:<pre><code class="clj">cljs-http/cljs-http {:mvn/version &quot;0.1.46&quot;}
org.clojars.arthurbarroso/re-frame-cljs-http {:mvn/version &quot;0.1.0&quot;}
</code></pre></p><p>Com as dependências instaladas, vamos mudar/criar nosso event handler <code>fetch</code><pre><code class="clj">&#40;ns app.events
  &#40;:require &#91;re-frame-cljs-http.http-fx&#93;
            &#91;re-frame.core :as re-frame&#93;&#41;&#41;

&#40;re-frame/reg-event-fx
  ::init-db
  &#40;fn &#91;&#95; &#95;&#93;
    {:db
       {:name &quot;app&quot;
        :loading false
        :error nil
        :users &#91;&#93;}}&#41;&#41;

&#40;re-frame/reg-event-db
  ::change-name
  &#40;fn &#91;db &#91;&#95; v&#93;&#93;
    &#40;assoc db :name v&#41;&#41;&#41;

&#40;re-frame/reg-event-db
  ::success
  &#40;fn &#91;db &#91;&#95; result&#93;&#93;
    &#40;assoc db :users &#40;-&gt; result :body :data&#41;&#41;&#41;&#41;

&#40;re-frame/reg-event-db
  ::failure
  &#40;fn &#91;db &#91;&#95; result&#93;&#93;
    &#40;assoc db :users &#91;&#93; :http-failure true :http-error result&#41;&#41;&#41;

&#40;re-frame/reg-event-fx
  ::fetch
  &#40;fn &#91;cofx &#91;&#95; &#95;&#93;&#93;
    {:db &#40;assoc &#40;:db cofx&#41; :b true&#41;
     :http-cljs {:method :get
                 :url &quot;https://reqres.in/api/users?page=2&quot;
                 :params {:testing true}
                 :timeout 8000
                 :on-success &#91;::success&#93;
                 :on-failure &#91;::failure&#93;}}&#41;&#41;
</code></pre></p><p>Agora, ao acessar a aplicação e clicar o botão "Fetch users" deve adicionar os resultados da request HTTP à lista de usuários.</p><h3>Segundo setup: Chrome headless com Etaoin</h3><p>Não escreverei muito deste setup aqui. <a href='https://medium.com/@joelsanchezclj/prerendering-a-re-frame-app-with-chrome-headless-bb875de31fd0'>O post escrito por Joel Sánchez</a> cobre bem o assunto. Esse setup é de longe um dos mais fáceis de se fazer funcionar. Você pode fazer como o post dele sugere (usando um esquema de server-side rendering da sua aplicação) ou usá-lo para gerar HTMLs estáticos.</p><h3>Terceiro setup: criando scripts de pré-render usando shadow-cljs</h3><p>Outra abordagem possível é criar um projeto shadow que rode duas builds separadas: uma que tenha como target o browser e outra que tenha como target um script node. Esse script node será o responsável por gerar o HTML pré-renderizado.</p><p>Usarei a mesma codebase dos setups anteriores para facilitar o setup. Para configurar isso, adicionremos dois novos builds a nosso <code>shadow-cljs.edn</code> e criaremos um novo arquivo de código<pre><code class="clj">{:nrepl {:port 8777}

 :deps true

 :dev-http
 {8280 &quot;public&quot;}

 :builds
   {:app {:target :graaljs
          :output-to &quot;public/assets/graal.js&quot;
          :entries &#91;app.component&#93;
          :jvm-opts &#91;&quot;-Xmx4G&quot;&#93;
          :modules
          {:app {:init-fn &#91;app.component/countinghtml&#93;
                 :prepend-js &quot;./graal-bootstrap.js&quot;}}
          :build-hooks &#91;&#40;util.clean-static/static-hook&#41;&#93;}
     :browser {:target     :browser
               :output-dir &quot;public/assets/js&quot;
               :asset-path &quot;/js&quot;

               :jvm-opts &#91;&quot;-Xmx6G&quot;&#93;
               :module-loader true

               :modules
               {:shared {}
                :counting {:entries &#91;app.component
                                     app.events
                                     app.subs
                                     app.render-server
                                     app.render-client&#93;
                           :depends-on #{:shared}}}}

     :pre-render {:target :node-script
                  :main app.render-server/main-to-html
                  :output-to &quot;public/prerenderscript.js&quot;}}}
</code></pre></p><pre><code class="clj">&#40;ns app.render-server
  &#40;:require &#91;app.component :refer &#91;counting-component&#93;&#93;
            &#91;app.events :as events&#93;
            &#91;clojure.string :as string&#93;
            &#91;re-frame.core :as re-frame&#93;
            &#91;reagent.core :as r&#93;
            &#91;reagent.dom.server :as dom-server&#93;
            &#91;&quot;react-dom&quot; :as react-dom&#93;
            &#91;&quot;fs&quot; :as fs&#93;&#41;&#41;

&#40;defn &#94;:export main-hydrate &#91;&#93;
  &#40;re-frame/dispatch-sync &#91;::events/init-db&#93;&#41;
  &#40;let &#91;cb &#40;.getElementById js/document &quot;root&quot;&#41;&#93;
    &#40;react-dom/hydrate &#40;r/as-element &#91;counting-component&#93;&#41;
                       cb&#41;&#41;&#41;

&#40;defn main-to-html &#91;&#93;
  &#40;re-frame/dispatch-sync &#91;::events/init-db&#93;&#41;
  &#40;let &#91;html-base &quot;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset=\&quot;utf-8\&quot;&gt;
    &lt;script src=\&quot;/assets/js/shared.js\&quot;&gt;&lt;/script&gt;
    &lt;script src=\&quot;/assets/js/counting.js\&quot;&gt;&lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id=\&quot;root\&quot;&gt;${{html-string}}&lt;/div&gt;
  &lt;/body&gt;
  &lt;script&gt;app.render&#95;server.main&#95;hydrate&#40;&#41;;&lt;/script&gt;
&lt;/html&gt;&quot;
        pre-rendered-view &#40;dom-server/render-to-string &#91;counting-component&#93;&#41;
        final &#40;clojure.string/replace html-base &quot;${{html-string}}&quot; pre-rendered-view&#41;&#93;
    &#40;fs/writeFileSync &quot;public/counting-view.html&quot; final&#41;&#41;&#41;
</code></pre><p>A build <code>browser</code> cria a build de browser. Essa build é importante pois torna possível importar o javascript necessário para nossa página (existem outras maneiras de fazer isso, mas você provavelmente consegue descobrí-las sozinho). A build <code>pre-render</code> usa as funções do nosso novo namespace para criar um script node que usa <code>fs</code> para criar o HTML pré-renderizado.</p><p>Com isso configurado, é hora de rodar <code>clj -M:cljs compile pre-render</code>, depois <code>clj -M:cljs watch app</code> e depois acessar <code>http://localhost:8280/couting-view.html</code>.</p><h3>Quarto setup: usando nbb</h3><p><a href='https://github.com/borkdude/nbb'>nbb</a> é uma ferramenta para scripting ad-hoc em clojurescript. Ela permite que usemos CLojurescript para rodar scripts em Node.js.</p><p>Para pré-renderizarmos a aplicação com nbb, primeiro iremos modificar nosso <code>counting-component</code> para que ele aceite uma prop initial-data. Falaremos mais sobre essa prop em breve.<pre><code class="clj">&#40;defn counting-component &#91;initial-data&#93;
  &#40;let &#91;click-2 &#40;reagent/atom 0&#41;
        name &#40;re-frame/subscribe &#91;::subs/name&#93;&#41;
        users &#40;re-frame/subscribe &#91;::subs/users&#93;&#41;&#93;
    &#40;fn &#91;&#93;
      &#91;:div
       &quot;The atom &quot; &#91;:code &quot;click-count&quot;&#93; &quot; has value: &quot;
       @click-2 &quot;. &quot;
       &#91;:p &quot;Name has value &quot; &#40;if @name @name &#40;:name initial-data&#41;&#41;&#93;
       &#91;:p &quot;Users:&quot;
        &#40;for &#91;user &#40;if @users @users &#40;:users initial-data&#41;&#41;&#93;
          &#94;{:key &#40;:id user&#41;}
          &#91;:p &#40;:first&#95;name user&#41;&#93;&#41;&#93;
       &#91;:p &quot;Test 2&quot;&#93;
       &#91;:input {:type &quot;button&quot; :value &quot;Click me!&quot;
                :on-click #&#40;swap! click-2 inc&#41;}&#93;
       &#91;:button {:on-click #&#40;re-frame/dispatch &#91;::events/change-name &quot;teste&quot;&#93;&#41;}
        &quot;Change name&quot;&#93;
       &#91;:button {:on-click #&#40;re-frame/dispatch &#91;::events/fetch&#93;&#41;}
        &quot;Fetch users&quot;&#93;&#93;&#41;&#41;&#41;
</code></pre></p><p>Iremos então modificar nossa função <code>app.render-server/main-to-html</code> para que ela também aceite dados (initial-data)<pre><code class="clj">&#40;defn &#94;:export main-hydrate &#91;&#93;
  &#40;re-frame/dispatch-sync &#91;::events/init-db&#93;&#41;
  &#40;let &#91;cb &#40;.getElementById js/document &quot;root&quot;&#41;&#93;
    &#40;react-dom/hydrate &#40;r/as-element &#91;counting-component&#93;&#41;
                       cb&#41;&#41;&#41;

&#40;defn main-to-html &#91;initial-data&#93;
  &#40;re-frame/dispatch-sync &#91;::events/init-db&#93;&#41;
  &#40;let &#91;html-base &quot;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset=\&quot;utf-8\&quot;&gt;
    &lt;script src=\&quot;/assets/js/shared.js\&quot;&gt;&lt;/script&gt;
    &lt;script src=\&quot;/assets/js/counting.js\&quot;&gt;&lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id=\&quot;root\&quot;&gt;${{html-string}}&lt;/div&gt;
  &lt;/body&gt;
  &lt;script&gt;app.render&#95;server.main&#95;hydrate&#40;&#41;;&lt;/script&gt;
&lt;/html&gt;&quot;
        pre-rendered-view &#40;dom-server/render-to-string &#91;counting-component initial-data&#93;&#41;
        final &#40;clojure.string/replace html-base &quot;${{html-string}}&quot; pre-rendered-view&#41;&#93;
    &#40;fs/writeFileSync &quot;public/counting-view.html&quot; final&#41;&#41;&#41;
</code></pre></p><p>Agora, por fim, criaremos nosso script no root do projeto:<pre><code class="clj">&#40;ns re-frame.core&#41;

&#40;defn reg-event-db &#91;&amp; &#95;args&#93;&#41;
&#40;defn reg-event-fx &#91;&amp; &#95;args&#93;&#41;
&#40;defn reg-sub &#91;&amp; &#95;args&#93;&#41;
&#40;defn subscribe &#91;&amp; &#95;args&#93; &#40;atom false&#41;&#41;
&#40;defn dispatch &#91;&amp; &#95;args&#93;&#41;
&#40;defn dispatch-sync &#91;&amp; &#95;args&#93;&#41;

&#40;ns re-frame-cljs-http.http-fx&#41;

&#40;ns cljs-http&#41;

&#40;ns render
  &#40;:require &#91;app.render-server :refer &#91;main-to-html&#93;&#93;&#41;&#41;

&#40;defn render-server &#91;&#93;
  &#40;main-to-html {:name &quot;app&quot; :users &#91;&#93;}&#41;&#41;

&#40;println &#40;render-server&#41;&#41;
</code></pre></p><p>Você deve ter percebido algo estranho aqui: estamos redefinindo o namespace <code>re-frame.core</code> - isso é necessário pois o <a href='https://github.com/borkdude/nbb/issues/79'>nbb ainda não suporta o re-frame</a>, então o mockamos. Essa também a razão por precisarmos passar um initial-data para nossos componentes. Nosso initial-data deve ser igual ao conteúdo que será inicializado no db do re-frame para que o React não aponte erros de diferença entre o conteúdo renderizado e o conteúdo hidratado. Como nosso componente não está dentro do arquivo do script, precisamos passar nosso classpath ao script e rodá-lo:<pre><code class="bash">classpath=&quot;$&#40;clojure -A:nbb -Spath -Sdeps '{}'&#41;&quot;
nbb --classpath &quot;$classpath&quot; script.cljs
</code></pre></p><p>Agora deve ser possível rodar <code>clj -M:cljs watch browser</code> e visitar <code>http://localhost:8280/counting-view.html</code> para checar a página pré-renderizada.</p><h3>Concluindo</h3><p>Foi bem legal testar todas essas coisas: acabei aprendendo mais sobre React, Clojurescript e a web.</p><p>Gostaria de salientar que provavelmente existem outros setups melhores e mais seguros por aí, mas, como eu disse, eu queria testar e fazer as coisas sozinho. Se você precisa de algo pronto para a produção talvez faça mais sentido pesquisar no slack clojurians.</p><p>Se você gostaria de testar qualquer um dos setups listados neste post, recomendo que leve em conta as seguintes coisas:</p><ul><li>TOdos esses setups são <strong>altamente experimentais</strong></li><li>Você provavelmente não conseguirá utilizar <code>css-in-js</code></li><li>O terceiro setup requer mais boilerplate se você precisar usar bibliotecas "esm only"</li><li>A decisão de usar HTMLs estáticos ou fazer SSR deve ser baseada na performance de sua aplicação bem como seus requisitos</li><li>O setup com etaoin é provavelmente o mais fácil</li><li><a href='https://github.com/borkdude/nbb/pull/87'>Você pode fazer pull requests no repositório do nbb para adicionar coisas que ainda não estão disponíveis</a></li><li>Fazer o target <code>graaljs</code> rodar código assíncrono não é o melhor caminho</li></ul>
    </div>
</div>

            </div>
        </div>

        <div>
        </div>
    </div>
    <footer>Copyright &copy; 2021 Arthur Barroso</footer>
</div>
<script src="/js/clojure_highlighter.js"></script>
<script>
  document.addEventListener('DOMContentLoaded', (event) => {
      document.querySelectorAll('pre code:not(.clj)').forEach((el) => {
          hljs.highlightElement(el);
      });
  });
</script>
</body>
</html>
