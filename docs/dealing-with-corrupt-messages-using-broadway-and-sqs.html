<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
    <meta charset="utf-8"/>
    <title>((arthur barroso)): Dealing with corrupt messages using Broadway and SQS</title>
    
<meta name="keywords" content="">

<meta name="description" content="A brief post talking about data ingestion and error handling using Broadway and SQS queues">

<meta property="og:description" content="A brief post talking about data ingestion and error handling using Broadway and SQS queues">

<meta property="og:url" content="" />
<meta property="og:title" content="Dealing with corrupt messages using Broadway and SQS" />
<meta property="og:type" content="article" />
<meta property="og:image" content="https://www.arthurbrrs.me/img/collage/publicint.png"/>

    <link rel="canonical" href="">
    <link rel="shortcut icon" href="css/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,300;0,400;0,500;0,700;0,900;1,700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/github.min.css"/>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.min.js"></script>
    <link rel="stylesheet" href="/css/screen.css">
    <!-- <link href="css/screen.css" rel="stylesheet" type="text/css" /> -->
</head>
<body>


<nav class="navbar">
    <div class="container">
        <div class="navbar-header">
            <a class="navbar-title" href="/">((arthur barroso))</a>
            <ul class="navbar-list">
              <li><a href="/archives">archives</a></li>
              <li><a href="/collage">collage</a></li>
              <li><a href="/about">about</a></li>
            </ul>
        </div>
    </div>
</nav>


<div class="container">
    <div class="row">
        <div>
            <div id="content">
                
<div id="post">
    <div class="post-header">
        <div id="post-meta" class="row">
            <div class="col-lg-6">2021-11-22</div>
            
            <span class="col-lg-6">By: Arthur Barroso</span>
            
            
        </div>
        <h2>Dealing with corrupt messages using Broadway and SQS</h2>
    </div>
    <div>
        
        <p>For the past few months, I've been working on an Elixir project for a fintech. This project had one particularity: its main source of data would come from SQS queues -almost no data would be created from the application itself. Since SQS needed to be used, Broadway seemed like the right tool for the job.</p><p>In this post, I am going to talk a little about how I managed to set up a data ingestion pipeline using Broadway to consume data from an SQS queue while dealing with corrupt messages and other constraints. I'll use simpler schemas and data to represent stuff, but it should help you in complex cases, such as the one I went through.</p><h3>Base concerns</h3><p>The project needed to be able to turn the data that came from the SQS queue into its Ecto schemas and insert those into the database. This meant that it was needed to do some data transformation with the message's contents.</p><p>I had two main concerns while thinking about how to properly set up my data ingestion pipeline:</p><ul><li>Dealing with corrupt messages</li><li>Dealing with message's relationships</li></ul><p>Dealing with the possibility of having corrupt messages in the pipeline meant I had to do two things:</p><ul><li>Parse the message's JSON data into an elixir data structure</li><li>Check whether this data structure conforms to a pre-defined schema or struct. I used Ecto's embedded schemas for this.</li></ul><p>A constraint of this project was that it had many relationships in between its schemas and it was <strong>never</strong> supposed to insert data that had missing relationships counterparts. e.g.: If a message references a user that doesn't yet exist in the database it shouldn't yet be inserted/ingested -it should go back to the queue. e.g.:</p><ol><li>Message A is received and its content contains an order that belongs to a user X</li><li>The pipeline checks if user X is already in the application's database</li><li>If user X doesn't yet exist then message A should go back to the queue (and this should be repeated until user X exists or the message gets removed from the queue)</li><li>If user X exists then message A gets consumed/inserted and then gets acknowledged (removed from the queue)</li></ol><h3>Base application setup</h3><p>We'll start by creating a Phoenix application and adding Broadway and BroadwaySQS to our dependencies.<pre><code class="bash">mix phx.new post --no-html --no-assets --no-dashboard --no-live --no-mailer
</code></pre></p><pre><code class="elixir"># post/config/config.exs
config :post,
 generators: &#91;binary&#95;id: true&#93;,
 ecto&#95;repos: &#91;Post.Repo&#93;
 
config :post, Post.Repo,
 migration&#95;primary&#95;key: &#91;type: :binary&#95;id&#93;,
 migration&#95;foreign&#95;key: &#91;type: :binary&#95;id&#93;
</code></pre><pre><code class="elixir"># mix.exs
  defp deps do
    &#91;
      {:broadway, &quot;&#126;&gt; 1.0&quot;},
      {:broadway&#95;sqs, &quot;&#126;&gt; 0.7.0&quot;},
      {:hackney, &quot;&#126;&gt; 1.9&quot;}
    &#93;
  end
</code></pre><p>Having that setup, it is now time to get a Postgres database up and running, create our migrations, and then create our schemas.<pre><code class="bash">mix ecto.gen.migration add&#95;users &amp;&amp; mix ecto.gen.migration add&#95;orders
</code></pre></p><p>For this post, let's assume the messages our application will consume can be of two kinds:<pre><code class="json">// For the user:
{
 &quot;external&#95;id&quot;: &quot;some&#95;string&quot;,
 &quot;name&quot;: &quot;some&#95;string&quot;
}

// For an order:
{
 &quot;description&quot;: &quot;some&#95;string&quot;,
 &quot;cart&#95;list&quot;: &#91;
  {&quot;price&quot;: &quot;some&#95;decimal&quot;},
  {&quot;price&quot;: &quot;some&#95;decimal&quot;}
 &#93;,
 &quot;external&#95;id&quot;: &quot;some&#95;string&quot;,
 &quot;user&#95;id&quot;: &quot;some&#95;external&#95;id&#40;string&#41;&quot;
}
</code></pre></p><p>Similarly, we'll assume our schemas like the following:</p><pre><code>user {
  external&#95;id: string,
  name: string
}

order {
  description: string,
  price: decimal,
  user&#95;id: uuid
}
</code></pre><p>Users migration:<pre><code class="elixir">defmodule Post.Repo.Migrations.AddUsers do
  use Ecto.Migration

  def change do
    create table&#40;:users&#41; do
      add :name, :string, null: false
      add :external&#95;id, :string, null: false, unique: true
      timestamps&#40;&#41;
    end
  end
end
</code></pre></p><pre><code class="elixir">defmodule Post.Repo.Migrations.AddOrders do
  use Ecto.Migration

  def change do
    create table&#40;:orders&#41; do
      add :description, :string, null: false
      add :price, :decimal, null: false
      add :external&#95;id, :string, null: false, unique: true
      add :user&#95;id, references&#40;:users&#41;
      timestamps&#40;&#41;
    end
  end
end
</code></pre><p>With the migrations configured, lets run <code>mix ecto.setup</code> and create the schemas<pre><code class="elixir">defmodule Post.User do
  use Ecto.Schema
  import Ecto.Changeset

  @primary&#95;key {:id, :binary&#95;id, autogenerate: true}
  @fields &#91;:name, :external&#95;id&#93;

  schema &quot;users&quot; do
    field :name, :string
    field :external&#95;id, :string
  end

  def changeset&#40;params&#41; do
    %&#95;&#95;MODULE&#95;&#95;{}
    |&gt; cast&#40;params, @fields&#41;
    |&gt; unique&#95;constraint&#40;&#91;:external&#95;id&#93;&#41;
  end
end
</code></pre></p><pre><code class="elixir">defmodule Post.Order do
  use Ecto.Schema
  import Ecto.Changeset

  alias Post.User

  @primary&#95;key {:id, :binary&#95;id, autogenerate: true}
  @foreign&#95;key&#95;type :binary&#95;id
  @fields &#91;:description, :price, :external&#95;id, :user&#95;id&#93;

  schema &quot;orders&quot; do
    field :description, :string
    field :price, :decimal
    field :external&#95;id, :string

    timestamps&#40;&#41;
    belongs&#95;to :user, User
  end

  def changeset&#40;params&#41; do
    %&#95;&#95;MODULE&#95;&#95;{}
    |&gt; cast&#40;params, @fields&#41;
    |&gt; unique&#95;constraint&#40;&#91;:external&#95;id&#93;&#41;
  end
end
</code></pre><p>With the schemas set up, it is time to move on.</p><h3>Dealing with corrupt messages</h3><p>The first step to get Broadway and SQS up and running is to install its dependencies and configure the necessary keys. I won't go into much detail on Broadway's installation since this is well covered by its documentation. Let's create our "Pipeline" (which is how I'll call our SQS message consuming functions/steps):<pre><code class="elixir">defmodule Post.SQS.Broadway do
  use Broadway

  def start&#95;link&#40;&#95;opts&#41; do
    producer&#95;module = Application.fetch&#95;env!&#40;:post, :sqs&#95;producer&#41;

    Broadway.start&#95;link&#40;&#95;&#95;MODULE&#95;&#95;,
      name: &#95;&#95;MODULE&#95;&#95;,
      producer: &#91;
        module: producer&#95;module
      &#93;,
      processors: &#91;
        default: &#91;concurrency: 50&#93;
      &#93;,
      batchers: &#91;
        default: &#91;concurrency: 5, batch&#95;size: 10, batch&#95;timeout: 1000&#93;
      &#93;
    &#41;
  end

  def handle&#95;message&#40;&#95;processor&#95;name, message, &#95;context&#41; do
    message
  end

  def handle&#95;batch&#40;&#95;batcher, messages, &#95;batch&#95;info, &#95;config&#41; do
    messages
  end

  def handle&#95;failed&#40;messages, &#95;context&#41; do
	messages
  end
end
</code></pre></p><p>This pipeline is pretty dummy as of now: it simply passes messages throughout the callbacks. Let's now tackle our first problem: validating data integrity.</p><p>We'll start by defining a module and a utility function for handling message errors and encode the message's JSON data (I decided to use Jason, which was already included in the project)<pre><code class="elixir">defmodule Post.SQS.Handlers do
  alias Broadway.Message

  def handle&#95;error&#40;message, :invalid&#95;json&#41;,
    do: Message.failed&#40;message, Jason.encode!&#40;%{type: :malformed&#95;json}&#41;&#41;

  def wrapped&#95;decode&#40;json&#41; do
    case Jason.decode&#40;json&#41; do
      {:ok, data} -&gt; {:ok, data}
      {:error, &#95;r} -&gt; {:error, :invalid&#95;json}
    end
  end

  def verify&#40;%{data: data} = message&#41; do
    case wrapped&#95;decode&#40;data&#41; do
      {:ok, map} -&gt; Message.update&#95;data&#40;message, fn &#95; -&gt; map end&#41;
      {:error, message&#95;reason} -&gt; handle&#95;error&#40;message, message&#95;reason&#41;
    end
  end
end
</code></pre></p><p>The code above does two things:</p><ul><li>Wraps Jason.decode into a function that omits the decoding failure reason so we can get more consistent errors</li><li>Tries to decode a message's data. If it succeeds, then the message's data gets updated, if not, then the message gets flagged as a failure with the failure type being "malformed_json"</li></ul><p>The <code>handle&#95;error</code> function is pretty useful: using it we're able to attach error reasons to our messages and then decide how we'll handle their errors on the <code>handle&#95;failed</code> callback.</p><p>Now let's hook it to the pipeline and change the <code>handle&#95;failed</code> callback:<pre><code class="elixir"># Post.SQS.Broadway
  def handle&#95;message&#40;&#95;processor&#95;name, message, &#95;context&#41; do
    Handlers.verify&#40;message&#41;
  end
  
  def handle&#95;failed&#40;messages, &#95;context&#41; do
	  messages
  end

  def handle&#95;failed&#40;messages, &#95;context&#41; do
    statuses = Enum.map&#40;messages, fn %{status: status} -&gt; status end&#41;
    IO.inspect&#40;%{failed: &quot;failed&quot;, statuses: statuses}&#41;

    messages
    |&gt; Enum.map&#40;fn m -&gt; Broadway.Message.configure&#95;ack&#40;m, on&#95;failed: :ack&#41; end&#41;
  end
</code></pre></p><p>Since messages that aren't possible to decode can't be used, we'll simply log those and acknowledge them, so we don't end up processing these more than once.</p><p>The fact that Jason can decode a message isn't yet a guarantee the data the application receives is the way it should be: there may be type mismatches between the application schema and the json data, for example. To handle this, we'll define two of Ecto's embedded schemas.<pre><code class="elixir">defmodule Post.SQS.Fields do
  @doc &quot;&quot;&quot;
  A module containing utility functions for transforming
  changesets into result tuples
  &quot;&quot;&quot;

  defmacro &#95;&#95;using&#95;&#95;&#40;&#95;&#41; do
    quote do
      use Ecto.Schema

      import Ecto.Changeset
      import Post.SQS.Fields
    end
  end

  def parse&#40;
        %Ecto.Changeset{valid?: true, changes: changes},
        relationship&#95;keys
      &#41; do
    mounted&#95;relationships&#95;data =
      relationship&#95;keys
      |&gt; Enum.reduce&#40;changes, fn rlk, acc -&gt; map&#95;relationships&#95;from&#95;struct&#40;rlk, acc&#41; end&#41;

    {:ok, mounted&#95;relationships&#95;data}
  end

  def parse&#40;%Ecto.Changeset{valid?: false} = changeset, &#95;relationship&#95;keys&#41;,
    do: {:error, to&#95;errors&#40;changeset&#41;}

  def parse&#40;%Ecto.Changeset{
        valid?: true,
        changes: changes
      }&#41;,
      do: {:ok, changes}

  def parse&#40;%Ecto.Changeset{valid?: false} = changeset&#41;,
    do: {:error, to&#95;errors&#40;changeset&#41;}

  defp to&#95;errors&#40;changeset&#41;,
    do:
      Ecto.Changeset.traverse&#95;errors&#40;changeset, fn {message, opts} -&gt;
        Regex.replace&#40;&#126;r&quot;%{&#40;\w+&#41;}&quot;, message, fn &#95;, key -&gt;
          opts |&gt; Keyword.get&#40;String.to&#95;existing&#95;atom&#40;key&#41;, key&#41; |&gt; to&#95;string&#40;&#41;
        end&#41;
      end&#41;

  defp extract&#40;data&#41; when is&#95;list&#40;data&#41;, do: Enum.map&#40;data, &amp;Map.get&#40;&amp;1, :changes&#41;&#41;
  defp extract&#40;data&#41; when is&#95;map&#40;data&#41;, do: Map.get&#40;data, :changes&#41;

  def map&#95;relationships&#95;from&#95;struct&#40;key, item&#41; do
    relationship&#95;items =
      item
      |&gt; Map.get&#40;key&#41;
      |&gt; extract&#40;&#41;

    Map.put&#40;item, key, relationship&#95;items&#41;
  end
end
</code></pre></p><pre><code class="elixir">defmodule Post.SQS.User do
  use Post.SQS.Fields

  import Ecto.Changeset

  @fields &#91;:external&#95;id, :name&#93;

  embedded&#95;schema do
    field :external&#95;id, :string
    field :name, :string
  end

  def changeset&#40;params&#41; do
    %&#95;&#95;MODULE&#95;&#95;{}
    |&gt; cast&#40;params, @fields&#41;
    |&gt; validate&#95;required&#40;@fields&#41;
  end

  def to&#95;result&#40;user&#95;changeset&#41;, do: parse&#40;user&#95;changeset&#41;
end
</code></pre><pre><code class="elixir">defmodule Post.SQS.OrderItem do
  use Post.SQS.Fields

  @fields &#91;:price&#93;

  embedded&#95;schema do
    field :price, :decimal
  end

  def changeset&#40;&#95;order, params&#41; do
    %&#95;&#95;MODULE&#95;&#95;{}
    |&gt; cast&#40;params, @fields&#41;
    |&gt; validate&#95;required&#40;@fields&#41;
  end
end

defmodule Post.SQS.Order do
  use Post.SQS.Fields

  alias Post.SQS.OrderItem

  @fields &#91;:description, :external&#95;id, :user&#95;id&#93;

  embedded&#95;schema do
    field :external&#95;id, :string
    field :description, :string
    field :user&#95;id, :string

    embeds&#95;many :cart&#95;list, OrderItem
  end

  def changeset&#40;params&#41; do
    %&#95;&#95;MODULE&#95;&#95;{}
    |&gt; cast&#40;params, @fields&#41;
    |&gt; validate&#95;required&#40;@fields&#41;
    |&gt; cast&#95;embed&#40;:cart&#95;list, reqired: true&#41;
  end

  def to&#95;result&#40;order&#95;changeset&#41;, do: parse&#40;order&#95;changeset, &#91;:cart&#95;list&#93;&#41;
end
</code></pre><p>In order to use the changeset's for data checking, we'll modify our <code>Handlers.verify</code> function</p><pre><code class="elixir">  def handle&#95;error&#40;message, :unrecognized&#95;data&#95;structure&#41;,
    do: Message.failed&#40;message,
          Jason.encode!&#40;%{type: :unrecognized&#95;data&#95;structure}&#41;&#41;

  def handle&#95;error&#40;message, :changeset&#95;error&#41;,
    do: Message.failed&#40;message, Jason.encode!&#40;%{type: :changeset&#95;error}&#41;&#41;

  def verify&#95;changeset&#40;%{name: &#95;} = data&#41; do
    changeset = Post.SQS.User.changeset&#40;data&#41;
    case Post.SQS.User.to&#95;result&#40;changeset&#41; do
      {:ok, data} -&gt; {:ok, data}
      {:error, &#95;reason} -&gt; {:error, :changeset&#95;error}
    end
  end

  def verify&#95;changeset&#40;%{description: &#95;} = data&#41; do
    changeset = Post.SQS.Order.changeset&#40;data&#41;
    case Post.SQS.Order.to&#95;result&#40;changeset&#41; do
      {:ok, data} -&gt; {:ok, data}
      {:error, &#95;reason} -&gt; {:error, :changeset&#95;error}
    end
  end

  def verify&#95;changeset&#40;&#95;data&#41;, do:
    {:error, :unrecognized&#95;data}

  def verify&#40;%{data: data} = message&#41; do
    with {:ok, map} &lt;- wrapped&#95;decode&#40;data&#41;,
         {:ok, verified&#95;data} &lt;- verify&#95;changeset&#40;map&#41; do
      Message.update&#95;data&#40;message, fn &#95; -&gt; verified&#95;data end&#41;
    else
      {:error, reason} -&gt;
        handle&#95;error&#40;message, reason&#41;
    end
  end
</code></pre><p>Our application is now ready to check whether messages are valid and conform to our specs.  If we then feed SQS a corrupt message while our application is running we'll see two things happening:</p><ul><li>Our application logging the failed message</li><li>The failed message being acknowledged (and therefore not being consumed again)</li></ul><h3>Messages and relationships</h3><p>As previously stated, every Order in our application depends on the existence of a user with the order's <code>user&#95;id</code>. Let's say we receive a message that contains an order with the user_id of <code>x123</code>, but there is no user with an <code>external&#95;id</code> for this value in our database. How can we handle this situation?</p><p>There are two main ways we can tackle this issue:</p><ul><li>Inserting the order and later creating its relationships</li><li>Sending back the order's message to the queue hoping a message for the user with <code>external&#95;id: &quot;x123&quot;</code> gets into our queue before the order message "expires".</li></ul><p>To be quite honest, I'd <strong>always</strong> pick the first option, but I couldn't. For several reasons, the application I was working on wasn't allowed to have "incomplete" data. Since I ended up going with the second option, I'll talk about how I did it.</p><p>To start, we'll create a new module, which will be responsible for checking our order messages' relationships:<pre><code class="elixir">defmodule Post.SQS.Checker do
  import Ecto.Query

  alias Post.{Repo, User, SQS.Handlers}

  def get&#95;user&#95;by&#95;external&#95;id&#40;%{user&#95;id: user&#95;external&#95;id} = data&#41; do
    case Repo.one&#40;
          from&#40;u in User, where: field&#40;u, :external&#95;id&#41;
            == &#94;user&#95;external&#95;id, select: u&#41;&#41; do
      nil -&gt; {:error, :missing&#95;user}
      &#95;user -&gt; {:ok, data}
    end
  end

  def check&#95;dependencies&#40;%{user&#95;id: &#95;, description: &#95;} = data&#41;, do:
    get&#95;user&#95;by&#95;external&#95;id&#40;data&#41;

  def check&#95;dependencies&#40;%{name: &#95;, external&#95;id: &#95;} = data&#41;, do:
    {:ok, data}

  # There is no point in checking messages
  # that have failed the previous steps
  def check&#40;%{status: {:failed, &#95;reason}} = message&#41;, do: message

  def check&#40;%{data: data, status: :ok} = message&#41; do
    case check&#95;dependencies&#40;data&#41; do
      {:ok, &#95;data} -&gt; message
      {:error, error} -&gt; Handlers.handle&#95;error&#40;message, error&#41;
    end
  end
end
</code></pre></p><p>We'll also need to make sure our <code>Handlers.handle&#95;error</code> deals with the <code>missing&#95;user</code> error type:<pre><code class="elixir">  def handle&#95;error&#40;message, :invalid&#95;json&#41;,
    do: Message.failed&#40;message, Jason.encode!&#40;%{type: :malformed&#95;json}&#41;&#41;
</code></pre></p><p>It is then time to hook our <code>check</code> function to our pipeline using the <code>handle&#95;message</code> callback:<pre><code class="elixir">  def handle&#95;message&#40;&#95;processor&#95;name, message, &#95;context&#41; do
    message
    |&gt; Handlers.verify&#40;&#41;
    |&gt; Checker.check&#40;&#41;
  end
</code></pre></p><p>Since we implemented all the error handling using the <code>Handlers.handle&#95;error</code> function, we're now able to decide how to deal with the failed messages in <code>handle&#95;failed</code> by checking the message's error message (which is a JSON containing the error type):<pre><code class="elixir">  def extract&#95;error&#95;type&#40;%{status: status} = message&#41;, do:
    %{message: message, error: Jason.decode!&#40;status&#41;}

  def configure&#95;ack&#95;based&#95;on&#95;error&#40;
    %{error: %{type: :changeset&#95;error}, message: m}&#41;, do:
    Broadway.Message.configure&#95;ack&#40;m, on&#95;failed: :ack&#41;

  def configure&#95;ack&#95;based&#95;on&#95;error&#40;
    %{error: %{type: :invalid&#95;json}, message: m}&#41;, do:
    Broadway.Message.configure&#95;ack&#40;m, on&#95;failed: :ack&#41;

  def configure&#95;ack&#95;based&#95;on&#95;error&#40;
    %{error: %{type: :unrecognized&#95;data&#95;structure}, message: m}&#41;, do:
    Broadway.Message.configure&#95;ack&#40;m, on&#95;failed: :ack&#41;

  # When an user is missing we do not ackwnoledge the message
  # so it goes back to the queue :&#41;
  def configure&#95;ack&#95;based&#95;on&#95;error&#40;
    %{error: %{type: :missing&#95;user}, message: m}&#41;, do:
    Broadway.Message.configure&#95;ack&#40;m, on&#95;failed: :noop&#41;

  def handle&#95;failed&#40;messages, &#95;context&#41; do
    messages
    |&gt; Enum.map&#40;&amp;extract&#95;error&#95;type/1&#41;
    |&gt; Enum.map&#40;&amp;configure&#95;ack&#95;based&#95;on&#95;error/1&#41;
  end
</code></pre></p><p>There are a few situations that will flag a message as corrupt:</p><ul><li>A message that can't be decoded (invalid json)</li><li>A message that doesn't conform to our embedded schemas (changeset error)</li><li>A message that doesn't pattern match our functions (unrecognized<i>data</i>structure)</li></ul><p>Since corrupt messages can't be consumed we simply acknowledge them - it would also be wise to log these messages, which can be done using some of AWS's services or something like Sentry, AppSignal. </p><p>When messages that depend on data that doesn't yet exist (<code>missing&#95;user</code>, in this case) get through our pipeline, we simply send these back to the queue.</p><p>We would then be able to insert data into our database, but that is a point I wont cover since it is pretty straightforward.</p>
    </div>
</div>

            </div>
        </div>

        <div>
        </div>
    </div>
    <footer>Copyright &copy; 2021 Arthur Barroso</footer>
</div>
<script src="/js/clojure_highlighter.js"></script>
<script>
  document.addEventListener('DOMContentLoaded', (event) => {
      document.querySelectorAll('pre code:not(.clj)').forEach((el) => {
          hljs.highlightElement(el);
      });
  });
</script>
</body>
</html>
